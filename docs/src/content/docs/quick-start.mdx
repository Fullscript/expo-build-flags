---
title: Quick Start
description: Install expo-build-flags, define a flag, and use it in your app.
---

import { Tabs, TabItem, Steps, FileTree } from "@astrojs/starlight/components";

<Tabs syncKey="pkg">
  <TabItem label="npm">```bash npm install expo-build-flags ```</TabItem>
  <TabItem label="yarn">```bash yarn add expo-build-flags ```</TabItem>
  <TabItem label="pnpm">```bash pnpm add expo-build-flags ```</TabItem>
</Tabs>

`typescript` is a peer dependency and should already be in your Expo project.

<Steps>

1. **Initialize**

   <Tabs syncKey="pkg">
     <TabItem label="npm">```bash npx build-flags init ```</TabItem>
     <TabItem label="yarn">```bash yarn build-flags init ```</TabItem>
     <TabItem label="pnpm">```bash pnpm build-flags init ```</TabItem>
   </Tabs>

   This scaffolds a `flags.yml` at the project root, detects your source directory (`src/` or `app/`), generates the initial `buildFlags.ts` module, and adds the generated file to `.gitignore`.

2. **Define a flag**

   Open the generated `flags.yml` and add a flag:

   ```yaml title="flags.yml"
   mergePath: src/constants/buildFlags.ts
   flags:
     newCheckout:
       value: false
       meta:
         team: growth
   ```

   `mergePath` is the relative path where the generated TypeScript module will be written. The `value` field is the default boolean state of the flag.

3. **Generate the runtime module**

   <Tabs syncKey="pkg">
     <TabItem label="npm">```bash npx build-flags override ```</TabItem>
     <TabItem label="yarn">```bash yarn build-flags override ```</TabItem>
     <TabItem label="pnpm">```bash pnpm build-flags override ```</TabItem>
   </Tabs>

   This reads `flags.yml` and writes the module at your `mergePath`:

   ```ts title="src/constants/buildFlags.ts" {3}
   // This file is auto-generated by expo-build-flags
   export const BuildFlags = {
     newCheckout: false,
   };
   ```

4. **Use the flag in code**

   ```tsx title="src/screens/checkout.tsx"
   import { BuildFlags } from "../constants/buildFlags";

   export function CheckoutScreen() {
     if (BuildFlags.newCheckout) {
       return <NewCheckoutFlow />;
     }
     return <LegacyCheckoutFlow />;
   }
   ```

5. **Override a flag during development**

   Prefix a flag name with `+` to enable or `-` to disable:

   <Tabs syncKey="pkg">
     <TabItem label="npm">
       ```bash npx build-flags override +newCheckout ```
     </TabItem>
     <TabItem label="yarn">
       ```bash yarn build-flags override +newCheckout ```
     </TabItem>
     <TabItem label="pnpm">
       ```bash pnpm build-flags override +newCheckout ```
     </TabItem>
   </Tabs>

   The generated module now has `newCheckout: true`. Your bundle server picks up the change on the next reload.

</Steps>

Your project structure should now look like this:

<FileTree>
  - flags.yml - src/ - constants/ - **buildFlags.ts** (generated, gitignored) -
  screens/ - checkout.tsx - ...
</FileTree>

## Integrate into your dev workflow

Since the generated module is gitignored, new contributors won't have it after cloning. We recommend adding the override command to your `postinstall` script so it runs automatically after `npm install`:

```json title="package.json"
{
  "scripts": {
    "postinstall": "build-flags override"
  }
}
```

This ensures every developer has a valid `buildFlags.ts` without needing to remember a manual step.

## What's next?

From here you can layer on additional capabilities:

- **[Config Plugin](/recipes/config-plugin/)** -- set flags for EAS native builds via an environment variable.
- **[Babel Plugin](/recipes/babel-plugin/)** -- enable tree shaking so disabled features are stripped from production bundles.
- **[Flagged Autolinking](/recipes/flagged-autolinking/)** -- exclude native modules from autolinking when their flag is off.
- **[Flag Inversion](/recipes/flag-inversion/)** -- invert a flag's default value for specific bundle IDs.
